# This example demonstrates the use of a git repo as a hard-wired 
# input artifact. The argo repo is cloned to its target destination
# at '/src' for the main container to consume.
apiVersion: argoproj.io/v1alpha1
kind: Workflow
metadata:
  generateName: seldon-sk-deploy-
spec:
  entrypoint: workflow
  arguments:
    parameters:
    - name: version
      value: 0.1
    - name: github-user
      value: kubeflow
    - name: github-revision
      value: master
    - name: docker-user
      value: seldonio
    - name: build-push-image
      value: false
    - name: deploy-model
      value: false
    - name: docker-image-name
      value: emote_runtime
  volumes:
  - name: my-secret-vol
    secret:
      secretName: docker-credentials     # name of an existing k8s secret
  templates:
  - name: workflow
    steps:
    - - name: build-push 
        template: build-and-push
        when: "{{workflow.parameters.build-push-image}} == true"
    - - name: serve
        template: seldon
        when: "{{workflow.parameters.deploy-model}} == true"		
  - name: build-and-push
    inputs:
      artifacts:
      - name: argo-source
        path: /src/MLKubeflow
        git:
          repo: https://github.com/{{workflow.parameters.github-user}}/MLKubeflow.git
          revision: "{{workflow.parameters.github-revision}}"
    container:
      image: docker:17.10
      command: [sh,-c]
      args: ["cd /src/MLKubeflow/models/sk_mnist/runtime ; ls -la ; chmod 777 ./* ;export DOCKER_HOST='tcp://127.0.0.1:2375'; apk add --update openssl;wget https://github.com/openshift/source-to-image/releases/download/v1.1.9a/source-to-image-v1.1.9a-40ad911d-linux-amd64.tar.gz  ; tar -zxf source-to-image-v1.1.9a-40ad911d-linux-amd64.tar.gz; until docker ps; do sleep 3; done; ./s2i build . seldonio/seldon-core-s2i-python2 {{workflow.parameters.docker-user}}/{{workflow.parameters.docker-image-name}}:{{workflow.parameters.version}}; docker images; echo $DOCKER_PASSWORD | docker login --username=$DOCKER_USERNAME --password-stdin ; docker push {{workflow.parameters.docker-user}}/{{workflow.parameters.docker-image-name}}:{{workflow.parameters.version}}"]
      env:
      - name: DOCKER_HOST               #the docker daemon can be access on the standard port on localhost
        value: 127.0.0.1
      - name: DOCKER_USERNAME  # name of env var
        valueFrom:
          secretKeyRef:
            name: docker-credentials     # name of an existing k8s secret
            key: username     # 'key' subcomponent of the secret
      - name: DOCKER_PASSWORD  # name of env var
        valueFrom:
          secretKeyRef:
            name: docker-credentials     # name of an existing k8s secret
            key: password     # 'key' subcomponent of the secret
      volumeMounts:
      - name: my-secret-vol     # mount file containing secret at /secret/mountpath
        mountPath: "/secret/mountpath"
    sidecars:
    - name: dind
      image: docker:17.10-dind          #Docker already provides an image for running a Docker daemon
      securityContext:
        privileged: true                #the Docker daemon can only run in a privileged container
      # mirrorVolumeMounts will mount the same volumes specified in the main container
      # to the sidecar (including artifacts), at the same mountPaths. This enables
      # dind daemon to (partially) see the same filesystem as the main container in
      # order to use features such as docker volume binding.
      mirrorVolumeMounts: true
  - name: seldon
    resource:                   #indicates that this is a resource template
      action: apply             #can be any kubectl action (e.g. create, delete, apply, patch)
      #successCondition: ? 
      manifest: |   #put your kubernetes spec here
       apiVersion: "machinelearning.seldon.io/v1alpha2"
       kind: "SeldonDeployment"
       metadata: 
         labels: 
           app: "seldon"
         name: "emote-classifier"
       spec: 
         annotations: 
           deployment_version: "v1"
           project_name: "Emote"
         name: "emote-classifier"
         predictors: 
           - 
             annotations: 
               predictor_version: "v1"
             componentSpecs: 
             - spec: 
                 containers: 
                   - 
                     image: "{{workflow.parameters.docker-user}}/emote_runtime:{{workflow.parameters.version}}"
                     imagePullPolicy: "Always"
                     name: "emote-classifier"
                     volumeMounts: 
                       - 
                         mountPath: "/data"
                         name: "persistent-storage"
                 terminationGracePeriodSeconds: 1
                 volumes: 
                   - 
                     name: "persistent-storage"
                     volumeSource: 
                       persistentVolumeClaim: 
                         claimName: "nfs-1"
             graph: 
               children: []
               endpoint: 
                 type: "REST"
               name: "emote-classifier"
               type: "MODEL"
             name: "emote-classifier"
             replicas: 1


